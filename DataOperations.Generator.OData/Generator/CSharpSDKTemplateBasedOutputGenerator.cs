using System.Text;
namespace Generator.Outputs
{
    /// <summary>
    /// This class is used to generate the C# code for the it works in tandem with the IODataToSDKGenerator class
    /// It provides the writer methods that are called to do the code generation
    /// </summary>
    public class CSharpSDKTemplateBasedOutputGenerator : IOutputGenerator
    {
        public CSharpSDKTemplateBasedOutputGenerator(string TemplatePath)
        {
            this.TemplatePath = TemplatePath;
        }
        
        public string TemplatePath {get;set;} // Which folder are the templates in? 

        // Generates a simple code fragment 
        // We replace all entries in the Dictionary of substitutable fields 
        // (marked by {{field}}) in the template with the specified values
        public async Task<string> GenerateMember(string TemplateName, Dictionary<string, string> replaces = null)
        {
            string temp = (await File.ReadAllTextAsync(Path.Combine(TemplatePath, TemplateName + ".txt")));
            if (replaces != null)
            {
                foreach (var replace in replaces)
                {
                    temp = temp.Replace("{{" + replace.Key + "}}", replace.Value);
                }
            }
            return temp;
        }
        // Writes a full EntitySet Class to the stringbuilder 
        public async Task WriteEntitySetClass(string location, Schema sch, StringBuilder entitySetSb, EntitySet entSet)
        {
            entitySetSb.Clear();
            await WriteClassHeader(entitySetSb, entSet.Name, "EntitySet Generated by tool", "ClassHeaderInherits", $"ODataEntitySetOperations<{entSet.EntityType}>", "IOperationsDispatcher", "dispatcher", sch.Namespace);
            foreach (var actionimp in sch.EntityContainer.ActionImports.Where(e => e.EntitySet == entSet.Name))
            {
                await WriteActionImport(location, sch, entitySetSb, actionimp);
            }
            WriteClassFooter(entitySetSb);
            await WriteDTOClassCodeFile(location, sch, entitySetSb, entSet.Name);
        }
        // Writes a full 'Global Action' to the stringbuilder (i.e. not associated with an EntitySet)
        public async Task WriteAction(string location, Schema sch, StringBuilder globalActionsSb, Action action)
        {
            globalActionsSb.AppendLine(await GenerateMember("GlobalAction", new Dictionary<string, string>() { { "ActionName", action.Name }, { "RtnTypeName", this.GetNativePropertyType(action.ReturnType.Type, action.ReturnType.Nullable)} }));
        }

        public async Task WriteKeySet(string location, Schema sch, StringBuilder globalActionsSb, string KeyName, IEnumerable<string> KeyList, string LoopKeys = "")
        {
            globalActionsSb.AppendLine(await GenerateMember("GenericOverrideMethods", new Dictionary<string, string>() {{KeyName, string.Join(",", KeyList)},{"loop", LoopKeys}}));
        }
        public async ValueTask<string> GenerateKey(string location, Schema sch, StringBuilder globalActionsSb, string KeyName, IEnumerable<string> KeyList)
        {
            return (await GenerateMember("KeyAddition", new Dictionary<string, string>() {{"KeyName", KeyName}, {"KeyValues", string.Join(",", KeyList)}}));
        }        
        public async Task WriteActionImport(string location, Schema sch, StringBuilder globalActionsSb, ActionImport actionImport)
        {
            Action action = sch.Actions.Where(e => e.Name == actionImport.Name).First();
            globalActionsSb.AppendLine(await GenerateMember("GlobalActionNoPayload", new Dictionary<string, string>() { { "ActionName", action.Name }, { "ParameterType", this.GetNativePropertyType(action.Parameter.Type, action.Parameter.Nullable) }, { "ParameterName", action.Parameter.Name }, { "RtnTypeName", this.GetNativePropertyType(action.ReturnType.Type,action.ReturnType.Nullable)} }));
        }
        public async Task WriteComplexTypeClass(string location, Schema sch, StringBuilder thisClassSb, ComplexType entity)
        {
            string className;
            thisClassSb.Clear();
            className = entity.Name;
            await WriteClassHeader(thisClassSb, className, "ComplexType Generated by tool","ClassHeaderInherits","BaseDTOWithIDAndETag","","", sch.Namespace);
            foreach (var prop in entity.Properties)
            {
                // Variant of this depending on interrogating the type
                // thisClassSb.AppendLine(await GenerateMember("Property", new Dictionary<string, string>() { { "PropertyName", property.Name }, { "PropertyType", property.Type } }));
                await WriteProperty(thisClassSb, className, prop);
            }
            WriteClassFooter(thisClassSb);
            await WriteDTOClassCodeFile(location, sch, thisClassSb, className);
        }
        
        public async Task WriteEntityTypeClass(string location, Schema sch, StringBuilder thisClassSb, EntityType entity)
        {
            string className;
            thisClassSb.Clear();
            className = entity.Name;
            await WriteClassHeader(thisClassSb, className, "EntityType AutoGenerated by tool", "ClassHeaderInherits", "BaseDTOWithIDAndETag", "", "", sch.Namespace);
            foreach (var prop in entity.Properties)
            {
                await WriteProperty(thisClassSb, className, prop);
            }
            // Find the matching EntitySet for this entity 
            EntitySet entSet = sch.EntityContainer.EntitySets.Where(e => e.EntityType == sch.Namespace + "." + className).First();
            foreach (var prop in entity.NavigationProperties)
            {
                var npb = entSet.NavigationPropertyBindings.Where(e => e.Path == prop.Name).First();
                await WriteNavigationProperty(thisClassSb, className, sch.Namespace + "." + className, prop, sch, npb);
            }
            foreach (var actionimp in sch.EntityContainer.ActionImports.Where(e => e.EntitySet == entity.Name))
            {
                await WriteActionImport(location, sch, thisClassSb, actionimp);
            }   
            await WriteKeysAndFKs(location, sch, thisClassSb, entity);
            WriteClassFooter(thisClassSb);
            await WriteDTOClassCodeFile(location, sch, thisClassSb, className);

        }
        private async Task WriteKeysAndFKs(string location, Schema sch, StringBuilder thisClassSb, EntityType entity)
        {
            // Build Loop of FK Data
            StringBuilder fkSb = new StringBuilder();
            foreach (NavigationProperty fk in entity.FindNavigationProperties(sch))
            {
                if (fk.ReferentialConstraint != null)
                {
                    fkSb.AppendLine("                " + await GenerateKey(location, sch, thisClassSb, fk.Name, new List<string>() { "\"" + fk.ReferentialConstraint.ReferencedProperty + "|" + fk.ReferentialConstraint.Property + "\""}));
                }
                else
                {
                    List<string> keyset = new List<string>();
                    // keyset = fk.FindReferencedNavPropBinding(sch).Target
                    fkSb.AppendLine("                " + await GenerateKey(location, sch, thisClassSb, fk.Name, entity.GetKeyProperties(sch)));
                }
            };
            // Write the Keys
            await WriteKeySet(location, sch, thisClassSb, "PKID", entity.GetKeyProperties(sch), fkSb.ToString());
        }

        public async Task WriteDTOClassCodeFile(string location, Schema sch, StringBuilder thisClassSb, string className)
        {
            if (thisClassSb.Length > 0) await File.WriteAllTextAsync(Path.Combine(location, sch.Namespace, $"DataOperations.Data.{sch.Namespace}", className + ".cs"), thisClassSb.ToString());
        }

        // Outputs a class to disk in the Data Namespace area
        public async Task WriteWebJobsClassCodeFile(string location, Schema sch, StringBuilder thisClassSb, string className)
        {
            if (thisClassSb.Length > 0) await File.WriteAllTextAsync(Path.Combine(location, className + ".cs"), thisClassSb.ToString());
        }
        // Write the footer of a class
        public void WriteClassFooter(StringBuilder thisClassSb, string writeThis = "")
        {
            thisClassSb.AppendLine(writeThis);
            thisClassSb.AppendLine("    }");
            thisClassSb.AppendLine("}");
        }
        // Write the header of a class (including the usings, class name, namespace, and inheritance)
        public async Task WriteClassHeader(StringBuilder thisClassSb, string className, string comment, string template = "ClassHeaderInherits", string InheritsFrom = "BaseDTOWithIDAndETag", string InheritCtorTypeParamName = "", string InheritCtorParamName = "", string Namespace = "Generated")
        {
            thisClassSb.AppendLine("//" + comment);
            thisClassSb.AppendLine(await GenerateMember("Usings"));
            thisClassSb.AppendLine(await GenerateMember("NamespaceHeader", new Dictionary<string, string>(){{"NameSpace", Namespace}}));
            thisClassSb.AppendLine(await GenerateMember(template, new Dictionary<string, string>() { { "ClassName", className }, { "InheritsFrom", InheritsFrom } }));
            if(InheritCtorTypeParamName != "") thisClassSb.AppendLine(await GenerateMember("InheritedCtor", new Dictionary<string, string>() { { "ClassName", className }, { "CtorType", InheritCtorTypeParamName}, { "CtorParamName", InheritCtorParamName }}));
        } 
        // Write the header of a static class (including the usings, class name, namespace, and inheritance)
        public async Task WriteStaticClassHeader(StringBuilder thisClassSb, string className, string comment, string template = "ClassHeaderStatic", string Namespace = "Generated")
        {
            thisClassSb.AppendLine("//" + comment);
            thisClassSb.AppendLine(await GenerateMember("Usings"));
            thisClassSb.AppendLine(await GenerateMember("NamespaceHeader", new Dictionary<string, string>(){{"NameSpace", Namespace}}));
            thisClassSb.AppendLine(await GenerateMember(template, new Dictionary<string, string>() { { "ClassName", className } }));
    
        }
        public string GetNativePropertyType(string propType, bool Nullable)
        {
            switch (propType)
            {
                case "Edm.String":
                    if (Nullable)
                    {
                        return "string?";
                    }
                    else
                    {
                        return "string";
                    }

                case "Edm.Decimal":

                    if (Nullable)
                    {
                        return "decimal?";
                    }
                    else
                    {
                        return "decimal";
                    }

                case "Edm.DateTimeOffset":

                    if (Nullable)
                    {
                        return "DateTime?";
                    }
                    else
                    {
                        return "DateTime";
                    }

                case "Edm.Guid":
                    if (Nullable)
                    {
                        return "string?";
                    }
                    else
                    {
                        return "string";
                    }
                case "Edm.Byte":
                    if (Nullable)
                    {
                        return "byte?";
                    }
                    else
                    {
                        return "byte";
                    }

                case "Edm.Int32":
                    if (Nullable)
                    {
                        return "int?";
                    }
                    else
                    {
                        return "int";
                    }

                case "Edm.Int16":
                    if (Nullable)
                    {
                        return "short?";
                    }
                    else
                    {
                        return "short";
                    }

                case "Edm.Int64":
                    if (Nullable)
                    {
                        return "long?";
                    }
                    else
                    {
                        return "long";
                    }
                    

                default:

                    return propType;

            }
        }
        public async Task WriteProperty(StringBuilder thisClassSb, string className, Property prop)
        {
            string outTypeName = prop.Name;
            bool generated = false;

            if (prop.Annotation.Any((e => e.Term == "Core.Immutable")))
            {
                // private setter 
                thisClassSb.AppendLine(await GenerateMember("ImmutableProperty", new Dictionary<string, string>() { 
                        { "ClassName", className }, 
                        { "PropName", prop.Name }, 
                        { "TypeName", GetNativePropertyType(prop.Type, prop.Nullable)}
                    }
                ));
                generated = true; 
            }
            else
            {            
                switch (prop.Type)
                {
                    case "Edm.String":

                        if (prop.MaxLength != 0 && prop.Nullable == false)
                        {
                            thisClassSb.AppendLine(await GenerateMember("StringPropertyNotNullableWithLength", new Dictionary<string, string>() { { "ClassName", className }, { "PropName", prop.Name }, { "MaxLength", prop.MaxLength.ToString() }, { "TypeName", "string" } }));
                            generated = true;
                            break;
                        }
                        if (prop.Nullable == false)
                        {
                            thisClassSb.AppendLine(await GenerateMember("StringPropertyNotNullable", new Dictionary<string, string>() { { "ClassName", className }, { "PropName", prop.Name }, { "TypeName", "string" } }));
                            generated = true;
                            break;
                        }
                    
                        if (prop.MaxLength != 0)
                        {
                            thisClassSb.AppendLine(await GenerateMember("StringPropertyWithLength", new Dictionary<string, string>() { { "ClassName", className }, { "PropName", prop.Name }, { "TypeName", "string" }, { "MaxLength", prop.MaxLength.ToString() } }));
                            generated = true;
                            break;
                        }
                        break;

                    case "Edm.Decimal":

                        // ToDO: Add validation for decimal values
                        // is the decimal nullable? 
                        if (prop.Nullable)
                        {
                            outTypeName = "decimal?";
                        }
                        else
                        {
                            outTypeName = "decimal";
                        }
                        break;

                    default:
                        outTypeName = GetNativePropertyType(prop.Type, prop.Nullable);
                        break;
                }
            }
            if (!generated) thisClassSb.AppendLine(await GenerateMember("GenericProperty", new Dictionary<string, string>() { { "TypeName", outTypeName }, { "PropName", prop.Name } }));
        }
        public async Task WriteNavigationProperty(StringBuilder thisClassSb, string className, string fqClassName, NavigationProperty prop, Schema sch, NavigationPropertyBinding npb)
        {
            string dispaction = prop.Type.Contains("Collection(") ? "GetList" : "Get";

            // To find the key, read the EntitySet 
            EntitySet entSet = sch.EntityContainer.EntitySets.Where(e => e.EntityType == fqClassName).First();

            // Fetch the EntityType then parse the path Key/PropertyRef/Name and this is the name of the key field
            var et = sch.EntityTypes.Where(e => e.Name == className).First();
            var pref = et.Key.PropertyRef.First();
            var keyname = pref.Name; 

            bool isCollection = prop.Type.Contains("Collection(");
            string outTypeName = prop.Type.Replace("Collection(", "").Replace(")", ""); 
            if(prop.ReferentialConstraint != null)
            {
                // We have a referential constraint, so we need to find the name of the key field
                keyname = prop.ReferentialConstraint.Property;
            }
        
            if(isCollection) thisClassSb.AppendLine(await GenerateMember("1ToManyExpansionProperty", new Dictionary<string, string>() { { "TypeName", outTypeName }, { "PropName", prop.Name }, {"DispatcherAction", dispaction},{"KeyName", keyname}}));
            else thisClassSb.AppendLine(await GenerateMember("1To1ExpansionProperty", new Dictionary<string, string>() {{"Singular", ""},{ "TypeName", outTypeName }, { "PropName", prop.Name }, {"DispatcherAction", dispaction},{"KeyName", keyname}}));
        }
        public async Task WriteCustomCodeClass(string location, Schema sch, StringBuilder globalActionsSb, 
            string className, string comment, string template, 
            string inheritsFrom = "", string inheritCtorTypeParamName = "", string InjectedObjectType = "", 
            string InjectedObjectParamName = "", string extraFooter = "", string NameSpace = "GeneratedCode", bool staticclass = false,
            Func<string, Schema, StringBuilder, Task> internalProcessor = null
        )
        {
            globalActionsSb.Clear();
            // Build the ServiceRootSet
            if(staticclass) 
                await WriteStaticClassHeader(globalActionsSb, className, comment, "ClassHeaderStatic", sch.Namespace);
            else
                await WriteClassHeader(globalActionsSb, className, comment, template, inheritsFrom, InjectedObjectType, InjectedObjectParamName, sch.Namespace);

            if (internalProcessor != null)
            {
                await internalProcessor(location, sch, globalActionsSb);
            }

            WriteClassFooter(globalActionsSb, extraFooter);
            await WriteDTOClassCodeFile(location, sch, globalActionsSb, className);
            
        }
        public async Task WriteEntitySetFragment(string location, Schema sch, StringBuilder Sb, EntitySet es, string template)
        {
            Sb.AppendLine(await GenerateMember("DISet", new Dictionary<string, string>() {{"EntitySet", es.Name}}));
        }

        public async Task WriteTextFragment(StringBuilder diHsb, string v)
        {
           diHsb.AppendLine(await GenerateMember(v));
        }

        public async Task WriteProjectFile(string location, Schema sch, string template, string DiskNameSpace)
        {
            await File.WriteAllTextAsync(
                Path.Combine(location, $"DataOperations.{DiskNameSpace}.{sch.Namespace}.csproj"), 
                await GenerateMember($"Project_{template}", new Dictionary<string, string>(){{"NameSpace", sch.Namespace}})
            );
        }
    }
}