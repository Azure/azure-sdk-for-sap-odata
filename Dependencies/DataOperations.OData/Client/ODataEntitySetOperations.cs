namespace DataOperations
{
    // Repository Pattern - maps any type of BaseDTOWithIDAndETag
    // Our Default implementation is to use the HttpClient to call the backend store over OData v4 / REST noting the SAP annotations
    // But there is no reason why this should not be overridden to use something else like OData v2 / SOAP / 
    // Microsoft.OData / simple odata or whatever you want
    // The only requirement is that the Dispatcher must be able to dispatch the operations to the backend store
    // The IEntitySetOperations<T>  is responsible for the mapping of the operations to the backend store against an Autogenerated DTO of type T
    // The IOperationsDispatcher is injected into the IEntitySetOperations<T>, which is injected via the DI container for use 
    public class ODataEntitySetOperations<T> : IQuerySetOperations<T> where T : IBaseDTOWithIDAndETag
    {
        protected internal IOperationsDispatcher _dispatcher {get; private set;}
        
        // inject an IODataOperationsDispatcher to fire operations against the OData service
        public ODataEntitySetOperations(IOperationsDispatcher dispatcher)
        {
            _dispatcher = dispatcher;
        }
        public async Task<T> CreateAsync(T entity)
        {
            return AttachDispatcher(await _dispatcher.CreateAsync<T>(entity));
        }
        public async Task DeleteAsync(string ID, string eTag)
        {
            await _dispatcher.DeleteAsync<T>(ID, eTag);
        }
        public async Task<T> GetAsync(string Key = null, QueryExpand expand = null, QuerySelect select = null)
        {
            return AttachDispatcher(await _dispatcher.GetAsync<T>(Key, expand, select));
        }
        public async Task<T> GetAsync(Dictionary<string, object> KeyValues)
        {
            return AttachDispatcher(await _dispatcher.GetAsync<T>(KeyValues));
        }
        public async Task<IEnumerable<T>> GetListAsync(QueryTop top = null, QuerySkip skip = null, QueryOrderBy orderBy = null, QueryFilter filter = null, QueryExpand expand = null, QuerySelect select = null)
        {
            return AttachDispatcher(await _dispatcher.GetListAsync<T>(top, skip, orderBy, filter, expand, select));
        }
        public async Task<IEnumerable<T>> GetListAsync(Dictionary<string, object> KeyValues) 
        {
            return AttachDispatcher(await _dispatcher.GetListAsync<T>(KeyValues));
        }
        public async Task UpdateAsync(T entity)
        {
            await _dispatcher.UpdateAsync(entity);
        }
        private T AttachDispatcher(T entity)
        {
            entity.AttachDispatcher<T>(_dispatcher);
            return entity;
        }
        private IEnumerable<T> AttachDispatcher(IEnumerable<T> entityList)
        {
            foreach(T item in entityList)
            {
                item.AttachDispatcher<T>(_dispatcher);
            }
            return entityList;
        }

    }
}